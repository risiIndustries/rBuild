import os
import shutil
import sys
from pathlib import Path

import rbuild as Base
import subprocess
import yaml

import time
from datetime import datetime


class RpmBuilder(Base.PackageBuilder):
    def __init__(self, packages: list = []):
        super().__init__(packages)

    def build_packages(self):
        for package in self._packages:
            subprocess.run(["rpmbuild", "-bb", package.directory])


class RpmPackage(Base.CustomPackage):
    def __init__(self, name: str, directory: str):
        super().__init__(name, directory)

        self.spec_replace = {}

    def build(self):
        subprocess.run(["rpmbuild", "-bb", self.directory])

    def get_spec_file(self):
        for file in os.listdir(self.directory):
            if file == (f"{self.name}.spec"):
                return os.path.join(self.directory, self.get_spec_file())
        return None

    def edit_template(self):
        with open(self.get_spec_file(), "r") as f:
            spec = f.read()
            for key, value in self.spec_replace.items():
                spec = spec.replace(key, value)
        with open(self.get_spec_file(), "w") as f:
            f.write(spec)


class KickStartRepository:
    def __init__(self, name: str, arguments: dict):
        self.name = name
        self.arguments = arguments


def cleanup_kickstarts():
    if os.path.exists(os.getcwd() + "/kickstarts"):
        shutil.rmtree(os.getcwd() + "/kickstarts")


class KickStartBuilder(Base.IsoBuilder):
    def __init__(self, metadata: Base.DistroMetadata = None, packages: Base.DistroPackages = None):
        super().__init__(metadata, packages)
        self._base_kickstarts = []
        self._base_kickstart_version = None
        self._kickstart_repos = []
        self._kickstart_git_repo = ""
        self._kickstart_git_branch = ""
        self._mock_chroot = ""
        self._custom_kickstart_code = ""
        self._part_size = None
        self._package_builder = RpmBuilder()

    def set_size(self, size: int):
        self._part_size = size

    def get_size(self) -> int:
        return self._part_size

    def set_base_kickstarts(self, base_kickstarts: list):
        self._base_kickstarts = base_kickstarts

    def add_base_kickstart(self, base_kickstart: str):
        self._base_kickstarts.append(base_kickstart)

    def add_repository(self, repo: KickStartRepository):
        self._kickstart_repos.append(repo)

    def remove_repository(self, repo_name: str):
        for repo in self._kickstart_repos:
            if repo.name == repo_name:
                self._kickstart_repos.remove(repo)

    def set_repositories(self, repos: list):
        self._kickstart_repos = repos

    def get_repositories(self) -> list:
        return self._kickstart_repos

    def remove_base_kickstart(self, base_kickstart: str):
        if base_kickstart in self._base_kickstarts:
            self._base_kickstarts.remove(base_kickstart)

    def set_base_kickstart(self, base_kickstart: str):
        self._base_kickstarts = [base_kickstart]

    def get_base_kickstarts(self) -> list:
        return self._base_kickstarts

    def set_base_kickstart_version(self, version: str):
        self._base_kickstart_version = version

    def get_base_kickstart_version(self) -> str:
        return self._base_kickstart_version

    def set_git(self, git_repo: str, git_branch: str):
        self._kickstart_git_repo = git_repo
        self._kickstart_git_branch = git_branch

    def get_git(self) -> tuple:
        return self._kickstart_git_repo, self._kickstart_git_branch

    def set_mock_chroot(self, chroot: str):
        self._mock_chroot = chroot

    def get_mock_chroot(self) -> str:
        return self._mock_chroot

    def generate_kickstart(self) -> str:  # Returns kickstart path
        ks = ["# AutoGenerated by rBuild"]
        for kickstart in self._base_kickstarts:
            ks.append(f"%include {kickstart}")
        for repo in self._kickstart_repos:
            args = []
            for key, value in repo.arguments.items():
                args.append(f"--{key}={value}")
            ks.append(f"repo --name=\"{repo.name}\" {' '.join(args)}")
        ks.append(self._custom_kickstart_code)
        if self._part_size is not None:
            ks.append(f"part / --size={self._part_size}")
        if self._distro_packages is not None and \
                self._distro_packages.get_packages() is not None and \
                self._distro_packages.get_removed_packages() is not None:
            ks.append("\n%packages")
            for package in self._distro_packages.get_packages():
                ks.append(package)
            for package in self._distro_packages.get_removed_packages():
                ks.append(f"-{package}")
            ks.append("\n%end")

        return "\n".join(ks)

    def download_flattened_kickstart(self):
        git = subprocess.run([
            "git", "clone", self._kickstart_git_repo, "-b",
            self._kickstart_git_branch, "--depth=1", "kickstarts"
        ])
        time.sleep(3)

        if git.returncode != 0:
            raise RuntimeError("Failed to download kickstarts")

        old_dir = os.getcwd()
        os.chdir(os.getcwd() + "/kickstarts")

        # Create base kickstart
        with open("base.ks", "w") as f:
            f.write(self.generate_kickstart())

        flat_ks = self.flatten_kickstart(old_dir)
        os.chdir(old_dir)
        cleanup_kickstarts()
        return flat_ks

    def download_unpatched_flatten_kickstart(self):
        git = subprocess.run([
            "git", "clone", self._kickstart_git_repo, "-b",
            self._kickstart_git_branch, "--depth=1", "kickstarts"
        ])

        if git.returncode != 0:
            raise RuntimeError("Failed to download kickstarts")

        old_dir = os.getcwd()
        os.chdir(os.getcwd() + "/kickstarts")

        # Create base kickstart for an unpatched combined base kickstart
        ks = []
        for kickstart in self._base_kickstarts:
            ks.append(f"%include {kickstart}")
        with open("base.ks", "w") as f:
            f.write("\n".join(ks))

        flatks = self.flatten_kickstart(old_dir)
        os.chdir(old_dir)
        cleanup_kickstarts()
        return flatks


    def flatten_kickstart(self, directory) -> str:
        flatten_ks = subprocess.run([
            "ksflatten", "-v,", "--config", "base.ks",
            "-o", f"{directory}/flat.ks", "--version", self._base_kickstart_version
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if flatten_ks.returncode != 0:
            print(flatten_ks.stdout, flatten_ks.stderr)
            raise RuntimeError("Failed to flatten kickstart")

        return f"{directory}/flat.ks"

    def get_base_packages(self) -> list:
        ks = self.download_unpatched_flatten_kickstart()

        # Parse kickstart for packages
        packages = []
        package_groups = []
        excluded_packages = []
        excluded_package_groups = []

        # Speghetti code to parse kickstart without pykickstart
        with open(ks, "r") as f:
            for line in f.readlines():
                if line.startswith("%packages"):
                    reading_packages = True
                    continue
                if not reading_packages:
                    continue
                if line.startswith("%end"):
                    reading_packages = False
                    continue
                package = []
                for i in line:
                    if i == " " or i == "\n":
                        if len(package) > 0:
                            if package[0:2] == "-@":
                                excluded_package_groups.append("".join(package[2:]))
                            elif package[0] == "-":
                                excluded_packages.append("".join(package[1:]))
                            elif package[0] == "@":
                                package_groups.append("".join(package[1:]))
                            else:
                                packages.append("".join(package))
                        break
                    if i == "#":
                        break
                    package.append(i)

        return packages, package_groups, excluded_packages, excluded_package_groups

    def set_custom_kickstart_code(self, custom_kickstart_code: str):
        self._custom_kickstart_code = custom_kickstart_code

    def get_custom_kickstart_code(self) -> str:
        return self._custom_kickstart_code

    @classmethod
    def new_from_yaml(cls, yaml_file: str):
        with open(yaml_file, "r") as f:
            data = yaml.safe_load(f.read())
            metadata = Base.DistroMetadata.new_from_yaml(yaml_file)
            packages = Base.DistroPackages.new_from_yaml(yaml_file)
            kickstart_data = data["KickStartBuilder"]

            # Create a new KickStartBuilder object using the DistroMetadata and DistroPackages objects
            kickstart_builder = cls(metadata, packages)

            # Set the base kickstart, version, and Git repository information
            kickstart_builder.set_base_kickstarts(kickstart_data["base_kickstarts"])
            kickstart_builder.set_base_kickstart_version(kickstart_data["base_version"])
            kickstart_builder.set_git(kickstart_data["base_git_url"],
                                      kickstart_data["base_git_branch"])
            kickstart_builder.set_mock_chroot(kickstart_data["mock_chroot"])

            # Adding repositories
            if "repositories" in kickstart_data:
                repositories = kickstart_data["repositories"]
                for repo in repositories:
                    kickstart_builder.add_repository(
                        KickStartRepository(repo, repositories[repo])
                    )

            if "size" in kickstart_data:
                kickstart_builder.set_size(kickstart_data["size"])

            # Set the custom kickstart code
            if "custom_code" in kickstart_data:
                kickstart_builder.set_custom_kickstart_code(f"{kickstart_data['custom_code']}")

            return kickstart_builder

    def build_iso(self):
        self._package_builder.build_packages()

        date = datetime.today().strftime('%Y%m%d')

        # Build the ISO
        subprocess.run(["mock", "--init", self._mock_chroot])
        self.mock_command(["--install", "pykickstart", "python3-kickstart", "lorax-lmc-novirt", "sed"])

        try:
            flat_ks = self.download_flattened_kickstart()
            self.mock_command(["--copyin", flat_ks, "flat.ks"])
        except RuntimeError:
            print("Couldn't flatten kickstart, attempting to flatten in the mock chroot")
            # move kickstarts directory to mock chroot
            self.mock_command(["--copyin", os.getcwd(), "kickstarts"])
            cleanup_kickstarts()

            # flatten command in mock chroot
            os.system(f'mock -r {self._mock_chroot} --isolation=simple --chroot '
                      f'"ksflatten -v, --config kickstarts/base.ks -o flat.ks '
                      f'--version {self._base_kickstart_version}"')

            # cleanup
            os.chdir(Path(os.getcwd()).parent.absolute())
        except Exception as e:
            print("Failed to flatten kickstart due to an unknown error. Cleaning mock.")
            self.mock_command(["--clean"])
            raise e
        name_spaceless = self._distro_metadata.name.replace(" ", "-")
        iso_name = f"{name_spaceless}-Live-{self._distro_metadata.version}-{date}"
        subprocess.run(
            f'mock --root {self._mock_chroot} --enable-network --isolation=simple --chroot "/sbin/livemedia-creator '
            f' --ks /flat.ks --logfile /var/tmp/lmc-logs/livemedia-out.log --no-virt --resultdir '
            f'/var/tmp/lmc --project {name_spaceless}-Live --make-iso --volid '
            f'{iso_name}.n.0 --iso-only --iso-name {iso_name}.iso '
            f'--releasever {self._distro_metadata.version} --macboot"',
            shell=True, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr
        )
        os.makedirs("build", exist_ok=True)
        self.mock_command([
            "--copyout",
            f"/var/tmp/lmc/{iso_name}.iso",
            f"build/{iso_name}.iso"
        ])
        self.mock_command(["--copyout", "/var/tmp/lmc-logs/livemedia-out.log", f"build/{iso_name}-livemedia-out.log"])
        self.mock_command(["--copyout", "/var/tmp/lmc-logs/anaconda/anaconda.log", f"build/{iso_name}-anaconda.log"])
        self.mock_command(["--clean"])

    def write_yaml(self, yaml_file: str):
        file_guts = yaml.safe_dump(self.to_dict())
        with open(yaml_file, "w") as f:
            f.write(file_guts)

    def to_dict(self) -> dict:
        repos = {}
        for repo in self._kickstart_repos:
            repos[repo.name] = repo.arguments
        dictionary = {
            "KickStartBuilder": {
                "base_kickstarts": self._base_kickstarts,
                "base_version": self._base_kickstart_version,
                "base_git_url": self._kickstart_git_repo,
                "base_git_branch": self._kickstart_git_branch,
                "mock_chroot": self._mock_chroot,
                "repositories": repos,
                "custom_code": self._custom_kickstart_code,
            }
        }
        if self._part_size is not None:
            dictionary["KickStartBuilder"]["size"] = self._part_size
        if self._distro_metadata is not None:
            dictionary.update(self._distro_metadata.to_dict())
        if self._package_builder is not None:
            dictionary.update(self._distro_packages.to_dict())
        return dictionary

    def mock_command(self, command: []):
        return subprocess.run(
            ["mock", "-r", self._mock_chroot] + command,
            stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin
        )


class GitError(RuntimeError):
    pass